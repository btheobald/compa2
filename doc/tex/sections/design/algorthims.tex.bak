Force Calculation Between Two Bodies (Ref S.1)
 
This equation can be used to calculate the gravitational force exerted by two masses on x and y components without the need to use the trigonometric functions.
Required Parameters
Gravitational Constant. ()
Mass of body 1. ()
Mass of body 2. ()
Distance between bodies. ()
Distance between bodies on component axis. ( or ) [Must Retain Correct Sign]

Calculation of all Forces (Ref S.2)
In order to simulate the interaction of multiple bodies, all relationships between bodies must be calculated, this can be presented as an undirected graph in an abstract sense. This also means that it can be represented as a matrix. 
When showing this organisation structure as a matrix, it becomes clear as to how many calculations need to be done in order to calculate all the required relationships.
Because the ‘graph’ is undirected, the matrix would be mirrored, the same force applies to both bodies in a relationship.
In order to reduce wasted memory footprint and increase ease of passing the variable, the x and y forces can be packed into the same matrix. (Will require slightly more complex programming when accessing the forces.)
Sign of the force must be retained, meaning that the way round that the force is calculated must be constant throughout all. (x to y)
The number of individual calculations that need to be done becomes:

Required Parameters
Current Number of bodies.
Scenario Body Structure.

Summation of Forces on Bodies (Ref S.3)
The forces on each body must be summed up so the total force on each body can be resolved to two numbers for x and y respectively.
Because the force is only stored in the matrix an implied direction, in certain cases it may be necessary to flip the sign of some of the results to correctly sum the answers
Results should be stored in an individual bodies dataset.
The force is calculated x to y on the matrix, meaning that all forces will initially be calculated with a sign that represents this direction. (The sign of the unit vector distance)
This function will need to ‘traverse’ the matrix in a similar way to the previous function, but only add a force if one of the loop axis is equal to the current body id.
If the body id is found in the first array access column, the original sign is kept. If it is found in the second, the sign must be flipped to preserve the correct direction of force relative to the body.
Required Parameters
Current Number of bodies
Scenario Body Structure
Scenario Component Force Matrix

Integration of New Position (Ref S.4)
Using the leapfrog integration method, calculates change in velocity and change in position/acceleration out of step with each other in order to reduce deviation.
Must be calculated in order  .
Initial acceleration must be calculated as new velocity is calculated at start of loop.
Newton’s Second Law states: 
In order to calculate the acceleration of each body the force stored in each bodies data structure is simply divided by the mass of the object.
Change in Velocity is defined as: , however the leapfrog integration method requires velocity at half a time step, so by halving the result you end up with the change in velocity for half a time step.
Change in Positon is: , this calculation is carried out with ½  velocity over the full time step.
Acceleration is calculated for a second time and the velocity is updated for another half time step.
Each time the Acceleration is updated the forces should also be recalculated.
This process should be carried out on all bodies involved in the simulation in step.
Required Parameters
Current Number of bodies
Scenario Body Structure


Body Collision Detection and Calculation (Ref S.5)
The simulation will have a simple body collision detection algorithm implemented.
One of the attributes that is stored for each body will be its radius, this value is used for giving the body a physical size when rendering, this value can also be used in a rudimentary but fast method.
Because the radius is constant around the whole of the body, collision detection can be done by simply checking the distance between two bodies and comparing it to the sum of the radius of the two bodies, if the distance is smaller than a collision has been detected.
In the case that a simulation is detected, the momentum of each body can be found with , the mass of the two bodies can be added together into one of the bodies and another can be discarded, momentums can be added together and because momentum is conserved the new velocity can then be calculated with .
Required Attributes
Scenario Body Structure
Current Number of Bodies

Calculation of Frame Simulation Time (Ref S.6)
This needs to be done in order to ensure that the amount of simulation that is carried out per frame is constant and proportional to the current framerate of the output; this will ensure that the simulation continues at the same speed even if the framerate is lower than intended.
The target framerate for the simulation is 60fps, by default, OpenGL will lock to the refresh rate of the monitor being used, this is generally 60Hz. Some monitors however can go up to 144 Hz and if this algorithm was not in place the simulation would be displayed over twice as fast as on a 60 Hz monitor.
For this to work correctly and for the simulation to be sufficiently detached from framerate, not all simulation iterations will be displayed, instead, the simulation thread will run a number of iterations equal to the number of milliseconds per frame, this will result in some fairly tight timing requirements for the runtime of the code, however it should be attainable assuming that the body count is relatively low.
If this requirement does not provide enough time for the iterations to complete, the number of iterations required can be divided by two or more to increase time between iterations.
It may be necessary to monitor the average time taken for each iteration and have the algorithm calculate the number of iterations possible in the set time period, capped at a maximum number as to not advance the simulation too far per frame.
If the number of calculations that can be done in the time period set by the framerate  is lower than the target number of iterations per frame (1 iteration per ms), the system must dynamically adjust the number of iterations that are done per frame in order to keep the framerate at the intended value.
Once the correct number of iterations has been completed, the simulation thread will send the updated scenario to the shared memory.
As an example, in order to display at 60Hz, the screen must be updated every 16.7ms, truncating to 16ms, this means that 16 iterations must be completed per frame, with each iteration taking less than 1ms to complete. (Preferably less than this as there is some overhead to deal with also.)
Required Parameters
Scenario Body Structure
Current number of bodies
Current Display Framerate
Graphics
Circle Drawing Algorithm (Ref G.7)
This algorithm was sourced from: http://slabode.exofire.net/circle_draw.shtml
Because OpenGL does not support circle primitives, a circle must be drawn as a polygon with individual segments. (GL_POLYGON)
In order to do this the coordinates for each individual points are required in the global coordinate space.
This can be done in a simple loop using the trigonometric functions, however because the result of the trig functions is based on the angle of each segment, it remains a constant for each circle, and only needs to be calculated once in order to get an accurate result.

 & 
Initial:  & 



Required Parameters:
Centre point
Radius
Segments

Scenario Drawing Algorithm (Ref G.8)
This takes the scenario data and interprets it in a way that can be rendered.
Coordinates in the scenario data will be directly displayed onto the canvas, circles will be used for displaying the bodies.
This will be called every frame in order to draw the scene on the back buffer, a function is then called that swaps around the front and back buffers, displaying the front buffer on the screen and allowing the old frame on the back buffer to be cleared and a new frame to be drawn. (This is known as double buffering, fixes the issue of a flickering display when the display is cleared and redrawn.)
Required Parameters:
Scenario Body Structure
Current number of bodies
Interface
Body Selection (Ref I.9)
This algorithm is similar to that used in the collision detection code, but instead will make use of the mouse coordinates.
The mouse coordinates will need to be converted to the coordinates of the simulation to correctly check if the mouse is selecting a body.
The algorithm will be triggered on a mouse click, if it is detected to be other a body then that body is deemed selected and its attributes can be modified through the GUI.
Mouse coordinates are handled by GLFW.

Pan and Zoom (Ref I.10)
By holding middle click, the user will be able to pan the view around the scene.
By using the scroll wheel, the user will be able to zoom in and out of the scene.
Input is handled by GLFW. Functions will be linked that change the OpenGL view.

Scenario Saving and Loading (Ref I.11)
Scenario Saving will be controlled by the user with a button on the main GUI. It will be possible to enter a filename for the scenario before saving.
The program will save a text based file with extension .gsav in the directory that the program was launched in.
The file will contain a structured and compressed version of the scenario data, listing critical parts, such as the positions and attributes of all bodies (Size, Mass, Position, Acceleration, Velocity, Colour) as well as any constants. (Gravitational Constant, Time step, Current Simulation Time.)
In order to load a scenario, a .gsav file must be dragged and dropped onto the program window.
Required Parameters:
Scenario Body Structure
Management
Thread Synchronisation and Shared Data Management (Ref M.12)
After the simulation thread is started, it begins its simulation loop. Once it completes enough iterations to output a frame (Attempts 16 to start with.) it will attempt to place its data in the staging area that can also be accessed by the render thread.
 First it will check that any data already in the memory space has already been read and that there are no updates to the scenario on the input staging area, if neither of these are true it will put its current scenario into the storage area and set status bits to state that there is new data available.
If the simulation thread is able to complete the next frame of simulation before the render thread reads the new data, the simulation thread will wait until the status bits are cleared it its register.
When the render thread fetches new data to render, it checks that new data is available, if new data is not available it will wait / loop around again using its current data, however if data is available it will set lock on the data and will read out the new simulation data, when done it will clear the lock and the status bit for new data available and begin the drawing and rendering of the scene.
The simulation thread can then put in new data and begin simulating the next frame.
If input data is received by the render thread, it will modify its local storage scenario and put that data into its shared storage area as well as setting appropriate status bits, the simulation thread will check these before it puts in its own new data and will simulate a new frame with the new information it has received.
User input will always cause the simulation thread to discard any currently held simulation it may have in its local storage.